<html>
	<head>
		<title>Starting Code for 1st Project 2017</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="src/WhiteChapel.js"></script>
	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats, time, old_frame, this_frame;
		var randomCubes, vol_dim = 100;
		var EPS = 0.1;
		
		//return array with height data from img, taken from: http://danni-three.blogspot.it/2013/09/threejs-heightmaps.html
		function getHeightData(img,scale) {
  
		 if (scale == undefined) scale=1;
  
		    var canvas = document.createElement( 'canvas' );
		    canvas.width = img.width;
		    canvas.height = img.height;
		    var context = canvas.getContext( '2d' );
 
		    var size = img.width * img.height;
			console.log(size);
		    var data = new Float32Array( size );
 
		    context.drawImage(img,0,0);
 
		    for ( var i = 0; i < size; i ++ ) {
		        data[i] = 0
		    }
 
		    var imgd = context.getImageData(0, 0, img.width, img.height);
		    var pix = imgd.data;
 
		    var j=0;
		    for (var i = 0; i<pix.length; i +=4) {
		        var all = pix[i]+pix[i+1]+pix[i+2];  // all is in range 0 - 255*3
		        data[j++] = scale*all/3;   
		    }
     
		    return data;
		}
		
		function Start() {
			InitGeometries();
			InitMaterials();

			scene = new THREE.Scene();
			scene.background = new THREE.Color("rgb(10%, 10%, 50%)"); //80, 90, 100
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.body.appendChild( renderer.domElement );
			
			camera.position.set(3,4,6);
			camera.lookAt( new THREE.Vector3(0,0,0));

			//Big Island creation
			var bigIsland = new BigIsland(new THREE.Vector3(0, -1.75, -17.5), new THREE.Vector3(0, 0, 0));
			scene.add(bigIsland.pivot);

			//Chapel creation
			var white_chapel = new Chapel(new THREE.Vector3(0,0,14.75), new THREE.Vector3(0,0,Math.PI), white_mat);
			scene.add(white_chapel.pivot);

			//Bridge creation
			var bridge = new Bridge(new THREE.Vector3(0,-1,0), new THREE.Vector3(0,0,0), white_mat);
			scene.add(bridge.pivot);
			
			//Random cube creation
			var cubes_velocity = 0.001;
			randomCubes = CreateRandomCubes(1000, white_mat, cubes_velocity, vol_dim);
			for(var i = 0; i < randomCubes.length; i++)
			{
				scene.add(randomCubes[i].mesh);
			}

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );

			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
			hemiLight.color.setRGB( 0.1, 0.1, 0.5);
			hemiLight.groundColor.setRGB( 0.1, 0.1, 0.5);
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );

			dirLight1 = new THREE.DirectionalLight( 0xffffff, 0.7 );
			dirLight1.color.setRGB( 1.0, 0.6, 0.4 );
			dirLight1.position.set( 0, 1.75, 0.5 );
			dirLight1.position.multiplyScalar( 50 );
			scene.add( dirLight1 );
			dirLight1.castShadow = true;

			dirLight2 = new THREE.DirectionalLight( 0xffffff, 0.5 );
			dirLight2.color.setRGB( 1, 1, 1 );
			dirLight2.position.set( 0, -1.75, 0.5 );
			dirLight2.position.multiplyScalar( 50 );
			scene.add( dirLight2 );
			dirLight2.castShadow = true;
			
			//Terrain creation
			var img = new Image();
			// load img source
			img.src = "textures/test2.png";
			img.onload = function () {
  
				//get height data from img
				var data = getHeightData(img,0.4);

				var terrain1 = new Terrain(data, img, 200, 200, new THREE.Vector3(0, -80, 0), new THREE.Vector3(0,0,0), white_mat);
				var terrain2 = new Terrain(data, img, 200, 200, new THREE.Vector3(0, +80, 0), new THREE.Vector3(Math.PI,0,0), white_mat);
				scene.add(terrain1.pivot);
				scene.add(terrain2.pivot);
			}	
			
			old_frame = Date.now();
			this_frame = 0;
		}
		
		function Update() {
			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}
		
		function Render() {
			this_frame = Date.now();
			time = this_frame - old_frame;
			old_frame = this_frame;

			UpdateRandomCubes(time, vol_dim);

			renderer.render(scene, camera);
		}

		function CreateRandomCubes(num_cubes, mat, cubes_vel, volume_dim)
		{
			var cubes = new Array();

			for(var i = 0; i < num_cubes; i++)
			{
				var rand_x;
				var rand_y;
				var rand_z;
				
				var done = false;
				while(!done)
				{
					rand_x = Math.random()*volume_dim - volume_dim/2;
					rand_y = Math.random()*volume_dim - volume_dim/2;
					rand_z = Math.random()*volume_dim - volume_dim/2;

					done = !((rand_x < 8.5 && rand_x > -8.5) && (rand_y < 10.5 && rand_y > -10.5) && (rand_z < 30.5 && rand_z > -30.5)); //Uses theese values for the inner forbidden zon to avoid 
					                                                                                                                     //generation of cubes on the boundary of the region
				}

				var rand_v_x = Math.random()*2 -1;
				var rand_v_y = Math.random()*2 -1;
				var rand_v_z = Math.random()*2 -1;

				cubes.push(new MovingCube(new THREE.Vector3(rand_x, rand_y, rand_z), new THREE.Vector3(0,0,0), mat, cubes_vel, new THREE.Vector3(rand_v_x, rand_v_y, rand_v_z)));
			}

			return cubes
		}

		function UpdateRandomCubes(time_passed, volume_dim)
		{		
			for(var i = 0; i < randomCubes.length; i++)
			{
				var coll = CalculateCubeCollision(i);

				if((Math.abs(randomCubes[i].mesh.position.x) >= volume_dim/2 || Math.abs(randomCubes[i].mesh.position.y) >= volume_dim/2 || Math.abs(randomCubes[i].mesh.position.z) >= volume_dim/2) ||
				   ((Math.abs(randomCubes[i].mesh.position.x) <= 8) && (Math.abs(randomCubes[i].mesh.position.y) <= 10+EPS) && (Math.abs(randomCubes[i].mesh.position.z) <= 30 )))
				{
					randomCubes[i].velocity_dir.x *= -1.0;
					randomCubes[i].velocity_dir.y *= -1.0;
					randomCubes[i].velocity_dir.z *= -1.0;
				}
				else if(coll.has_collided)
				{
					//Determine the position of the two cubes
					var pos1 = new THREE.Vector3();
					var pos2 = new THREE.Vector3();
					pos1.x = randomCubes[i].mesh.position.x;
					pos1.y = randomCubes[i].mesh.position.y;
					pos1.z = randomCubes[i].mesh.position.z;
					pos2.x = randomCubes[coll.cube_idx].mesh.position.x;
					pos2.y = randomCubes[coll.cube_idx].mesh.position.y;
					pos2.z = randomCubes[coll.cube_idx].mesh.position.z;

					//Calculate the distance vector between the twe positions
					var collision = new THREE.Vector3();
					collision.subVectors(pos2, pos1);
					var distance = collision.length();

					//handle of two cube generated in the same place
					if(distance == 0)
					{
						collision = new THREE.Vector3(1.0, 0.0, 0.0);
						distance = 1.0;
					}
					
					collision.normalize();
					//calculate the compoments of the two velocity of the cubes wich are parallel to the collision vector
					var this_pc = randomCubes[i].velocity_dir.dot(collision);
					var seco_pc = randomCubes[coll.cube_idx].velocity_dir.dot(collision);

					//calculate the output velocities 
					randomCubes[i].velocity_dir.addVectors(new THREE.Vector3(0,0,0), collision.multiplyScalar((seco_pc)));
					randomCubes[coll.cube_idx].velocity_dir.addVectors(new THREE.Vector3(0,0,0), collision.multiplyScalar((this_pc)));

					randomCubes[i].velocity_dir.normalize();
					randomCubes[coll.cube_idx].velocity_dir.normalize();
				}

				randomCubes[i].mesh.position.x += randomCubes[i].velocity_dir.x * randomCubes[i].velocity_mag * time_passed;
				randomCubes[i].mesh.position.y += randomCubes[i].velocity_dir.y * randomCubes[i].velocity_mag * time_passed;
				randomCubes[i].mesh.position.z += randomCubes[i].velocity_dir.z * randomCubes[i].velocity_mag * time_passed;	
					
			}
		}

		function CalculateCubeCollision(f_c)
		{
			for(var s_c = 0; s_c < randomCubes.length; s_c++)
			{
				if((Math.abs(randomCubes[s_c].mesh.position.x - randomCubes[f_c].mesh.position.x) <= 1.0) &&
				   (Math.abs(randomCubes[s_c].mesh.position.y - randomCubes[f_c].mesh.position.y) <= 1.0) &&
				   (Math.abs(randomCubes[s_c].mesh.position.z - randomCubes[f_c].mesh.position.z) <= 1.0) && s_c != f_c)
					return {"has_collided": true, "cube_idx": s_c};
			}

			return {"has collided": false, "cube_idx": -1};
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>